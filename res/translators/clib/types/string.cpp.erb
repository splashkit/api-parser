<%#
    Strings from a std::string in the SK code must be allocated on heap and
    freed after use. An example would be:

    1. SK function `Foo' returns a `std::string'
    2. Wrap `std::string' as `__sklib_string'
    3. Return `__sklib_string'
    4. Language `Bar' calls Lib function `Foo' returning the `__sklib_string'
    5. Wrap the returned `__sklib_string''s underlying `char*` in `Bar::String'
    6. Free the returned `__sklib_string' from the heap
    7. Return the wrapped `Bar::String'
%>
typedef struct
{
  char *string;
  int size;
} __sklib_string;
<%
    # Must forward declare C Library free function as external "C" if not yet declared
    # before we declare the non-C Library free function
    unless free_heap_allocated?
%>
extern "C" void <%= CLib::FUNC_PREFIX %>__free__sklib_string(__sklib_string s);
<%
    end # end unless
%>
void <%= func_prefix %>__free__sklib_string(__sklib_string s)
{
<%
    # This call effectively selects which way it should free the heap memory.
    # If it should free heap allocated memory, then it will using free (i.e.,
    # C Library code) otherwise it will call the CLib implementation of the
    # free code (i.e., C++ code).
    unless free_heap_allocated?
%>
    <%= CLib::FUNC_PREFIX %>__free__sklib_string(s);
<%
    else
%>
    free(s.string);
<%
    end # end unless
%>
}
__sklib_string <%= func_prefix %>__to_sklib_string(const std::string &s)
{
  __sklib_string __skreturn;
  __skreturn.size = (int)s.length();
  __skreturn.string = (char *)malloc(__skreturn.size + 1);
  strcpy(__skreturn.string, s.c_str());
  return __skreturn;
}
std::string <%= func_prefix %>__to_string(const __sklib_string &s)
{
    std:string result = std::string(s.string);
    <%= func_prefix %>__free__sklib_string(s);
    return result;
}
